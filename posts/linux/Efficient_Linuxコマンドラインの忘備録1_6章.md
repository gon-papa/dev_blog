---
id: c601e3b4-ab16-f1ea-5b87-aa183efa83c1
title: Efficient_Linuxコマンドラインの忘備録1~6章
date: '2025-11-19'
tags:
- linux
- bash
---

# Efficient Linuxコマンドラインの忘備録

Linuxコマンドの扱いが貧弱だなと業務で感じていて、書店に立ち寄ったら目に入り購入しました。
忘備録として、ここに記載していく。
主に1~6章までの紹介されている基礎的なコマンドです。
これらは私が気になった部分のみ抽出して記載しています。

## ファイルの文字列操作系

以下は操作対象ファイルである

```text
python	Programming Python	2010	Lutz, Mark
snail	SSH, The Secure Shell	2005	Barrett, Daniel
alpaca	Intermediate Perl	2012	Schwartz, Randal
robin	MySQL High Availability	2014	Bell, Charles
horse	Linux in a Nutshell	2009	Siever, Ellen
donkey	Cisco IOS in a Nutshell	2005	Boney, James
oryx	Writing Word Macros	1999	Roman, Steven
```

### WCコマンド

wcコマンドはファイル内の行数(-l)、単語数(-w)、文字数(-c)を表示する。文字数のカウントについては各行の改行文字(見えない)も含めてカウントする。

```bash
wc file.txt
->
7 51 325 file.txt
```

このためパイプで繋いで使用することができる

```bash
ls -1 | wc -l
->
4(カレントディレクトリのファイル数を確認できる)
```

(ls -1はlsはstdoutかそうでないかで挙動が変わるため。stdoutの場合は見やすさを優先して1行で表示するが、そうでない場合は複数行で表示する)

### cutコマンド

ファイルから1つ以上の列を表示する。以下の場合は2列目を抽出している(f)

デフォルトはタブ文字によって区切りで抽出される

```bash
cut -f2 file.txt
->
Programming Python
SSH, The Secure Shell
Intermediate Perl
MySQL High Availability
Linux in a Nutshell
Cisco IOS in a Nutshell
Writing Word Macros
```

また`,`や`-`を使用して、列の複数選択や範囲選択も可能となる。

`-d`オプションで区切り文字を変更することができる。(デフォルトはタブが区切り文字)

```bash
cut -f2,4 file.txt
cut -f2-4 file.txt
```

## grepコマンド

ここでは指定された文字列にマッチする行を表示するにフォーカスする

```bash
grep Nutshell file.txt 
->
horse   Linux in a Nutshell     2009    Siever, Ellen
donkey  Cisco IOS in a Nutshell 2005    Boney, James
```

`-v`でマッチしない行を表示することもできる

```bash
grep -v Nutshell file.txt 
->
python  Programming Python      2010    Lutz, Mark
snail   SSH, The Secure Shell   2005    Barrett, Daniel
alpaca  Intermediate Perl       2012    Schwartz, Randal
robin   MySQL High Availability 2014    Bell, Charles
oryx    Writing Word Macros     1999    Roman, Steven
```

対象ファイルにワイルドカードを指定すれば複数ファイルから一致する文字列も検索できる

```bash
grep Perl *.txt

->
ファイル名 行
...
...
```

### uniqコマンド

uniqコマンドはファイル内で重複している隣り合った行を検出する。

```bash
uniq sample.txt
```

あくまで隣り合った重複する値を行を削除するため、

```bash
A
A
B
A
C
C
↓
A
B
A
C
```

のようにAが先頭にあろうが、Bの次のAは残るととなる。

`-C`で出現回数をカウントすることもできる

```bash
uniq -c sample.txt
->
2 A
1 B
1 C
2 C
```

### 出力リダイレクト

`>`でファイルに出力できる。(上書き)

`>>`でファイルに追記できる.

あくまでstdoutの出力になるため、stderrの出力を行うには`2>`にしないとファイルに出力されない。

stdoutとstderrの両方をリダイレクトするには`&>`とすることで可能となる。

```bash
ls -a > file
cat file
->
.
..
file
sample
test.txt


```

### 入力リダイレクト

`<`を使用するとstdinの読み込み先をキーボードからファイルに変更できる。

```bash
wc < file
 5  5 26
```

## コマンド履歴系

### historyコマンド

シェルで実行したコマンドの履歴を標準出力する

`-c`で履歴削除もできる

```bash
history
->
1 ls -a
2 cat file
...
```

コマンド履歴が保持されていることがわかったところで履歴からコマンドを呼び出す方法を3つ記載する

1. キーボードの上下カーソル移動(説明するまでもないのでスキップする)
2. 履歴展開
3. インクリメンタル検索

#### 履歴展開

特別な指揮を使ってコマンド履歴にアクセスする機能。

`!`で始まる。


| 記号     | 意味                                       | コマンド |
| ---------- | :------------------------------------------- | ---------- |
| !        | 直前のコマンドを実行                       | !!       |
| n        | 履歴番号nのコマンドを実行                  | !1       |
| -n       | 現在からn個前のコマンドを実行              | !n-1     |
| string   | stringで始まる最新コマンドを実行           | !cat     |
| ?string? | 曖昧検索に引っかかった最新のコマンドを実行 | !?ca?    |

**この通りにコマンドを打つと実行されてしまうため、不用意なミスを避けるためには確認が必要となる**

`:p`をオプションで渡せば、実行せずにコマンドを標準出力してくれる

```bash
!!:p
->
ls -a
# 直前のコマンドを:pを使用して確認した

!!
# 実行されなかったとしてもコマンドの履歴に登録するため、直前のコマンドとして素早く実行することができる
```

また履歴のコマンドの引数を違うコマンドに渡すこともできる

```bash
ls *.txt

rm !$
```


| 記号 | 意味                        | コマンド |
| ------ | ----------------------------- | ---------- |
| $    | 直前のコマンドの最後の引数  | !$       |
| *    | 直前のコマンドの全ての引数  | !*       |
| ^    | 直前のコマンドの最初の引数  | !^       |
| n    | 直前のコマンドのn番目の引数 | !3       |

#### インクリメンタル検索

`Ctr - R`でインクリメンタル検索ができる

任意の部分の入力を行うたびに履歴にヒットした最も新しいコマンドを表示する希望するコマンドが現れたらenterで決定すれば実行できる。

また候補をもっと遡りたい場合は`Ctr - R`を押し続ければ合致しそうな履歴を遡ってくれる。

### コマンドライン編集

コマンドラインを編集する3つの方法

1. カーソル移動(説明するまでもないのでスキップする)
2. キャレット記法
3. Emacs or Vimスタイルのキーストローク

#### キャレット記法

`^`を用いて、直前のコマンドラインの単語を置き換えることができる

```bash
ls -a

# キャレットで挟んで、その後に変更したい文字を置いて実行するとaがlとなり実行される
^a^l
->
ls -l
```

1文字なのであまり効果はないが、もっと複雑なコマンドラインを用いる場合はカーソル移動よりも素早くコマンドラインの入力ミスを修正できる

#### Vimスタイルのキーストローク(Emacsは省略)

デフォルトはEmacsなのでviに変更

```bash
set -i vi

# Emacsに戻すには
set -o emacs
```

vimスタイル

#### 基本移動


| 動作           | コマンド |
| ---------------- | ---------- |
| 左へ移動       | h        |
| 下へ移動       | j        |
| 上へ移動       | k        |
| 右へ移動       | l        |
| 行頭へ         | 0        |
| 先頭非空白へ   | ^        |
| 行末へ         | $        |
| 次の単語先頭へ | w        |
| 前の単語先頭へ | b        |
| 次の単語末尾へ | e        |
| ファイル先頭へ | gg       |
| ファイル末尾へ | G        |

#### 編集（INSERTモード切替）


| 動作                 | コマンド |
| ---------------------- | ---------- |
| カーソル位置で挿入   | i        |
| 行頭に挿入           | I        |
| カーソルの後ろに挿入 | a        |
| 行末に挿入           | A        |
| 次の行に挿入         | o        |
| 前の行に挿入         | O        |

#### 削除


| 動作                | コマンド |
| --------------------- | ---------- |
| 1文字削除           | x        |
| 1文字削除してINSERT | s        |
| 行全体削除          | dd       |
| 単語削除            | dw       |
| 行末まで削除        | D        |
| 行頭まで削除        | d0       |
| 単語末尾まで削除    | de       |

#### ヤンク（コピー）


| 動作           | コマンド |
| ---------------- | ---------- |
| 行全体ヤンク   | yy       |
| 単語ヤンク     | yw       |
| 行末までヤンク | y$       |
| 行頭までヤンク | y0       |

#### ペースト


| 動作                     | コマンド |
| -------------------------- | ---------- |
| カーソルの後ろに貼り付け | p        |
| カーソルの前に貼り付け   | P        |

#### 検索


| 動作           | コマンド |
| ---------------- | ---------- |
| 前方検索       | /pattern |
| 後方検索       | ?pattern |
| 次の検索結果へ | n        |
| 前の検索結果へ | N        |

#### 置換


| 動作                   | コマンド      |
| ------------------------ | --------------- |
| 1文字置換              | r{char}       |
| 置換モード（連続置換） | R             |
| 行内置換               | :s/old/new/   |
| 全体置換               | :%s/old/new/g |

#### その他


| 動作                       | コマンド |
| ---------------------------- | ---------- |
| 元に戻す                   | u        |
| やり直し                   | Ctrl+r   |
| 半ページ上                 | Ctrl+u   |
| 半ページ下                 | Ctrl+d   |
| 可視化（文字単位）         | v        |
| 行選択（ビジュアルライン） | V        |
| ブロック選択               | Ctrl+v   |



## テキスト生成系

### dateコマンド

現在の日付と時刻を返す

`+`でフォーマットを指定できる。`%Y`など特別な式を含むことができる

```bash
date +%Y-%m-%d
->
2025-11-19

date
->
2025年 11月 19日 水曜日 03:48:07 UTC
```



## ファイル検索

### findコマンド

ディレクトリー内のファイルをサブディレクトリーへと再帰的に下降しながらリストアップし、それらのフルパスを表示する

```bash
find
->
今いるディレクトリ以下のサブディレクトリやファイルをすべて表示する
```

`-type f or d`を与えるとファイルかディレクトリのみを表示する

`-name`を与えるとパターンマッチを行い、一致するファイル名のみに限定できる。この際にシェルに先にパターン評価されないように引用符で囲むこと。

また`-iname`とすると大文字と小文字を区別しないでパターンマッチされる。

```bash
find . -type f -name "*.jpg"
# カレントディレクトリ以下(.の部分でパスを指定できる)でファイルでjpgの拡張子のものを全て表示する
```



## テキストの抽出

### grepコマンド

`-w`で単語のマッチを行う

`-i`で大文字と小文字を無視した単語のマッチを行う

`-l`で文字列を含んでいるファイル名のみを表示する

正規表現を用いて文字抽出を行う

```bash
grep -w  pengin text.txt
->
This is pengin
```

正規表現を用いずに固定文字列で抽出を行う場合は以下を使用する。

`-F`オプションや`fgrep`を用いると部分一致したものを抽出することもできる(エスケープが多い場合に有効)

### awkコマンド

awkは汎用のテキスト処理プログラムであり、今回はprintのみにフォーカスする。

cutコマンドでは実現できなかった方法でファイルから列を抽出する。

`/etc/hosts`はipアドレスの横に任意の数のスペースで区切られてホスト名が記載されている。

任意スペースが存在することによってcutコマンドは文字の位置によって並んでいるか？一貫した１つの文字によって区切られているかで列から文字を抽出するが、

今回は任意スペースのため、実現できない。awkであればこれが簡単にできる。

```bash
cat /etc/hosts

127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::  ip6-localnet
ff00::  ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.2      c5f317f1dcd1


awk '{print $2}' /etc/hosts
->
localhost
localhost
ip6-localnet
ip6-mcastprefix
ip6-allnodes
ip6-allrouters
c5f317f1dcd1

cut -f2 /etc/hosts
->
localhost
localhost ip6-localhost ip6-loopback # 対象外のものまで取得してしまう
ip6-localnet
ip6-mcastprefix
ip6-allnodes
ip6-allrouters
c5f317f1dcd1

```

awkは`$`の後に列番号を続けることで任意の列を参照することができる。(2桁の場合は`$(20)`のように記載すること)

awkのprintコマンドは整然とした列から逸脱したコマンド出力を処理するのに使用する。

### tacコマンド

catはファイルの中身を標準出力するが、tacは逆順でファイルの中身を標準出力する。これは時系列順に並んだログファイルを参照するときなどに有効である。(sort -rなどを使用できない場合など特に有効)

```bash
cat file
->
A
B
C

tac file
C
B
A
```

以上です。
7章以降はまた別の記事にて気になった部分を書こうと思います。
2章メモ

NoSQLが求められる背景p31
NoSQLは膨大なデータセットと書き込みスループットを含む、RDBで容易に実現できる以上のスケーラビリティが必要になり生まれた
RDBでスキーマよりも、NoSQLのスキーマは動的で表現力に富むデータモデルの要求


RDBやNoSQLで、データの使用目的と使用特性に応じて永続化を行う(ポリグロットパーシステス)p32
補足説明：特性を最大化するため「データの特性ごとに適材適所のデータベースの種類を使おう」というコンセプトが生まれました。
それが「ポリグロット・パーシステンス」です。

RDBの課題p32
App層でRDBからデータを使用する際に変換が必要(ORMは変換負荷を下げてくれるが、完璧ではない)
→所感として、やはりApp層でRDBのスキーマの概念を持ち込まないように変換をする必要があると思う。App層ではRDBスキーマの都合がロジックを汚染してはいけない。理由はデータ構造に合わせて、
処理が歪む可能性がある。データはロジックに合わせてシンプルかつ、必要最低限の量をリポジトリ層に近い層で成形して処理ロジックに渡すべきである。(そもそもRDBのデータモデルはデータの整合性を重視した、2次元表構造を持っており、リレーションで表現されるが、App層はひとまとまりのオブジェクトで表現され、使用される。この指向性の違いをインピーダンスミスマッチという)

多対1のドキュメントデータベースの課題p35
多対1(多くの人が1つの地域に住む、多くの人が、それぞれ1つの部署に配属されるなど)の場合、RDSはID(繋がりを抽象化している)を持たせてリレーションで表現することでデータは1つで済むが、ドキュメントデータベースの場合は、そもそもリレーショナル構造に対しての機能が弱い。そのため、データの重複も考慮する必要がある

多対1への対応
1.正規化
2.Json型、XML型
3.DBへのテキストとしてJson、XMLを変換して保存(文字列保存のためクエリ使えない！)

NoSQLはドキュメント指向データベースのため、Jsonをサポートしている(ツリー構造で表現する→ネストが深いと扱いが難しい)
そのため、リレーショナルな指向ではなくオブジェクトとしての指向のため、インピーダンスミスマッチは低減する
リレーションがないため、クエリも1つで済む

が、やはり多対1には弱く、App層で結合することになる
ドキュメント指向データベースは結合ではなく集約的なデータ構造のため、結合は苦手でサポートも弱いのである。

p42
ドキュメント指向データベースはスキーマレスというが、そんなことはない
構造を持っているため、データ取得時にApp層で暗黙的に決定しているに過ぎない
要はRDBはスキーマを事前に決定し使用しているが、ドキュメント指向データベースはデータの読み取り時にスキーマが確定する(スキーマは強制していないだけ)
スキーマオンリードなのである。
→RDBスキーマは静的型付け言語、ドキュメント指向データベーススキーマは動的型付け言語に似ているイメージ

p43
ドキュメント指向データベースには利点もあり、RDBはリレーションが多いほど、全てのデータを取得するには、複数回のインデックスのルックアップが必要になり、ディスクのシーク多く、時間も長くなる。
逆にドキュメント指向データベースは1回でツリー構造を取得するため、短い時間で効率的にデータを取得できる(ただし、1度にドキュメントの大部分が必要になる場合に限られる)

ルックアップ
インデックスから取得したキーを使って、実際のデータ（テーブルの行や別ページ）を探しに行く処理。
B-Treeインデックスで user_id = 123 を見つけた後、その行のアドレス（ROWIDやポインタ）をたどってテーブル本体から必要なカラムを取ってくる。
特徴:
    - インデックスだけで必要なカラムが揃えばルックアップは不要（カバリングインデックス）。
    - ルックアップ回数が多いとディスクI/Oが増えて遅くなる。

シーク
インデックス構造をたどって、目的のキーや範囲の先頭位置を特定する処理。
インデックスを頭から順に全部読む（スキャン）」ではなく、user_id = 123 の位置まで直接たどる動き。B-Treeなら木構造を辿って目的の葉ノードへジャンプ。
特徴:
	- シークは検索開始地点を特定する動作。
	- 範囲条件付きの場合は「シーク → その位置から順次読み込み」という流れになる。

ローカリティ
データが物理的に近い場所（同じディスクページやキャッシュ内）にまとまって存在している度合い。
「アクセスパターンの局所性」とも呼ばれる。
種類:
	- 空間的ローカリティ（Spatial Locality）: 近いアドレスのデータがまとめて必要になる傾向（例: 同じインデックスページ内に連続したキーが並んでいる）。
	- 時間的ローカリティ（Temporal Locality）: 最近使ったデータがまた使われやすい傾向（キャッシュヒット率に影響）。
特徴:
	- ローカリティが高いとキャッシュやディスク読み込み効率が上がる。
	- インデックスのカラム順やクラスタリングインデックスはローカリティ向上に寄与する。

1.	シーク → インデックスの「スタート地点」にピンポイントで移動
2.	ルックアップ → インデックスが指す本体データを取りに行く
3.	ローカリティ → そのデータが近くに固まっていると速い